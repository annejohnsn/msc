
with(DynamicSystems):
interface(rtablesize=500);

rho2_1 := proc (x, y) options operator, arrow; Fraction(1, 2^ordp(x-y, 2)) end proc;
S := getPadicProductOrdering(100, [2]);
getPartialRhoSeq(S, rho2_1);



#take the nth root to see what the capacity is approaching
root[100](getPartialRhoSeq(getPadicProductOrdering(100, [2]), rho2_1))
#create a function to do this iteratively:
g := x -> root[x-1](getPartialRhoSeq(getPadicProductOrdering(x, [2]), rho2_1))
map(g, [seq(i, i = 1 ..100)])
#look at the results for increasing n
DiscretePlot([seq(i, i = 1 .. 100)], [seq(g(i), i = 1 .. 100)], style = point)

rho2_2 := proc (x_1, x_2, y_1, y_2) options operator, arrow; d:= max(Fraction(1, 2^ordp(x_1-y_1, 2)), Fraction(1, 2^ordp(x_2-y_2, 2))); return d; end proc;
S := getPadicProductOrdering(100, [2, 2]);
getPartialRhoSeq(S, rho2_2);
g := x -> root[x-1](getPartialRhoSeq(getPadicProductOrdering(x, [2,2]), rho2_2))


rho23_2 := proc (x_1, x_2, y_1, y_2) options operator, arrow; d:= max(Fraction(1, 2^ordp(x_1-y_1, 2)), Fraction(1, 3^ordp(x_2-y_2, 3))); return d; end proc;
S := getPadicProductOrdering(101, [2, 3]);
getPartialRhoSeq(S, rho23_2);
g := x -> root[x-1](getPartialRhoSeq(getPadicProductOrdering(x, [2,3]), rho23_2))


guess := proc(n)
    local exp2, exp3, partial;
 
    exp2 := round(n*.133);
    exp3 := round(n*.064);

    partial := 2^(-exp2)*3^(-exp3);

    return root[n-1](partial);
 
end proc;

